// Copyright 2020 ConsenSys AG
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by gnark/internal/generators DO NOT EDIT

package backend_bn256

import (
	"fmt"
	"strconv"

	"github.com/consensys/gnark/backend"
	"github.com/consensys/gurvy/bn256/fr"

	"github.com/consensys/gnark/frontend"
	"github.com/consensys/gnark/internal/utils/debug"
)

// R1CS decsribes a set of R1CS constraint
type R1CS struct {
	// Wires
	NbWires        int
	NbPublicWires  int // includes ONE wire
	NbPrivateWires int
	PrivateWires   []string         // private wire names, correctly ordered (the i-th entry is the name of the (offset+)i-th wire)
	PublicWires    []string         // public wire names, correctly ordered (the i-th entry is the name of the (offset+)i-th wire)
	WireTags       map[int][]string // optional tags -- debug info

	// Constraints
	NbConstraints   int // total number of constraints
	NbCOConstraints int // number of constraints that need to be solved, the first of the Constraints slice
	Constraints     []R1C
}

// New return a typed R1CS with the curve from frontend.R1CS
func New(cs *frontend.CS) R1CS {

	r1cs := cs.ToR1CS()

	return Cast(r1cs)
}

// Cast casts a frontend.R1CS (whose coefficients are big.Int)
// into a specialized R1CS whose coefficients are fr elements
func Cast(r1cs *frontend.R1CS) R1CS {

	toReturn := R1CS{
		NbWires:         r1cs.NbWires,
		NbPublicWires:   r1cs.NbPublicWires,
		NbPrivateWires:  r1cs.NbPrivateWires,
		PrivateWires:    r1cs.PrivateWires,
		PublicWires:     r1cs.PublicWires,
		WireTags:        r1cs.WireTags,
		NbConstraints:   r1cs.NbConstraints,
		NbCOConstraints: r1cs.NbCOConstraints,
	}
	toReturn.Constraints = make([]R1C, len(r1cs.Constraints))
	for i := 0; i < len(r1cs.Constraints); i++ {
		from := r1cs.Constraints[i]
		to := R1C{
			Solver: from.Solver,
			L:      make(LinearExpression, len(from.L)),
			R:      make(LinearExpression, len(from.R)),
			O:      make(LinearExpression, len(from.O)),
		}

		for j := 0; j < len(from.L); j++ {
			to.L[j].ID = from.L[j].ID
			to.L[j].Coeff.SetBigInt(&from.L[j].Coeff)
		}
		for j := 0; j < len(from.R); j++ {
			to.R[j].ID = from.R[j].ID
			to.R[j].Coeff.SetBigInt(&from.R[j].Coeff)
		}
		for j := 0; j < len(from.O); j++ {
			to.O[j].ID = from.O[j].ID
			to.O[j].Coeff.SetBigInt(&from.O[j].Coeff)
		}

		toReturn.Constraints[i] = to
	}

	return toReturn
}

// Solve sets all the wires and returns the a, b, c vectors.
// the r1cs system should have been compiled before. The entries in a, b, c are in Montgomery form.
// assignment: map[string]value: contains the input variables
// a, b, c vectors: ab-c = hz
// wireValues =  [intermediateVariables | privateInputs | publicInputs]
func (r1cs *R1CS) Solve(assignment backend.Assignments, a, b, c, wireValues []fr.Element) error {

	// compute the wires and the a, b, c polynomials
	debug.Assert(len(a) == r1cs.NbConstraints)
	debug.Assert(len(b) == r1cs.NbConstraints)
	debug.Assert(len(c) == r1cs.NbConstraints)
	debug.Assert(len(wireValues) == r1cs.NbWires)

	// keep track of wire that have a value
	wireInstantiated := make([]bool, r1cs.NbWires)

	// instantiate the public/ private inputs
	instantiateInputs := func(offset int, visibility backend.Visibility, inputNames []string) error {
		for i := 0; i < len(inputNames); i++ {
			name := inputNames[i]
			if name == backend.OneWire {
				wireValues[i+offset].SetOne()
				wireInstantiated[i+offset] = true
			} else {
				if val, ok := assignment[name]; ok {
					if visibility == backend.Secret && val.IsPublic || visibility == backend.Public && !val.IsPublic {
						return fmt.Errorf("%q: %w", name, backend.ErrInputVisiblity)
					}
					wireValues[i+offset].SetBigInt(&val.Value)
					wireInstantiated[i+offset] = true
				} else {
					return fmt.Errorf("%q: %w", name, backend.ErrInputNotSet)
				}
			}
		}
		return nil
	}
	// instantiate private inputs
	debug.Assert(len(r1cs.PrivateWires) == r1cs.NbPrivateWires)
	debug.Assert(len(r1cs.PublicWires) == r1cs.NbPublicWires)
	if r1cs.NbPrivateWires != 0 {
		offset := r1cs.NbWires - r1cs.NbPublicWires - r1cs.NbPrivateWires // private input start index
		if err := instantiateInputs(offset, backend.Secret, r1cs.PrivateWires); err != nil {
			return err
		}
	}
	// instantiate public inputs
	{
		offset := r1cs.NbWires - r1cs.NbPublicWires // public input start index
		if err := instantiateInputs(offset, backend.Public, r1cs.PublicWires); err != nil {
			return err
		}
	}

	// check if there is an inconsistant constraint
	var check fr.Element

	// Loop through the other Constraints
	for i, r1c := range r1cs.Constraints {

		if i < r1cs.NbCOConstraints {
			// computationalGraph : we need to solve the constraint
			// computationalGraph[i] contains exactly one uncomputed wire (due
			// to the graph being correctly ordered), we solve it
			r1cs.Constraints[i].solveR1c(wireInstantiated, wireValues)
		}

		// A this stage we are not guaranteed that a[i+sizecg]*b[i+sizecg]=c[i+sizecg] because we only query the values (computed
		// at the previous step)
		a[i], b[i], c[i] = r1c.instantiate(r1cs, wireValues)

		// check that the constraint is satisfied
		check.Mul(&a[i], &b[i])
		if !check.Equal(&c[i]) {
			invalidA := a[i]
			invalidB := b[i]
			invalidC := c[i]

			return fmt.Errorf("%w: %q * %q != %q", backend.ErrUnsatisfiedConstraint,
				invalidA.String(),
				invalidB.String(),
				invalidC.String())
		}
	}

	return nil
}

// Inspect returns the tagged variables with their corresponding value
// If showsInput is set, it also puts in the resulting map the inputs (public and private).
func (r1cs *R1CS) Inspect(solution backend.Assignments, showsInputs bool) (map[string]fr.Element, error) {

	res := make(map[string]fr.Element)

	var root fr.Element
	fftDomain := NewDomain(root, MaxOrder, r1cs.NbConstraints)

	wireValues := make([]fr.Element, r1cs.NbWires)
	a := make([]fr.Element, r1cs.NbConstraints, fftDomain.Cardinality)
	b := make([]fr.Element, r1cs.NbConstraints, fftDomain.Cardinality)
	c := make([]fr.Element, r1cs.NbConstraints, fftDomain.Cardinality)

	err := r1cs.Solve(solution, a, b, c, wireValues)

	// showsInput is set, put the inputs in the resulting map
	if showsInputs {
		offset := r1cs.NbWires - r1cs.NbPublicWires - r1cs.NbPrivateWires // private input start index
		for i := 0; i < len(r1cs.PrivateWires); i++ {
			res[r1cs.PrivateWires[i]] = wireValues[i+offset]
		}
		offset = r1cs.NbWires - r1cs.NbPublicWires // public input start index
		for i := 0; i < len(r1cs.PublicWires); i++ {
			res[r1cs.PublicWires[i]] = wireValues[i+offset]
		}
	}

	// get the tagged variables
	for wireID, tags := range r1cs.WireTags {
		for _, tag := range tags {
			if _, ok := res[tag]; ok {
				// TODO checking duplicates should be done in the frontend, probably in cs.ToR1CS()
				return nil, backend.ErrDuplicateTag(tag)
			}
			res[tag] = wireValues[wireID]
		}

	}

	// the error cannot be caught before because the res map needs to be filled
	if err != nil {
		return res, err
	}

	return res, nil
}

// method to solve a r1cs
type solvingMethod int

const (
	SingleOutput solvingMethod = iota
	BinaryDec
)

// Term lightweight version of a term, no pointers
type Term struct {
	ID    int64      // index of the constraint used to compute this wire
	Coeff fr.Element // coefficient by which the wire is multiplied
}

// String helper for Term
func (t Term) String() string {
	res := ""
	res = res + t.Coeff.String() + "*:" + strconv.Itoa(int(t.ID))
	return res
}

// LinearExpression lightweight version of linear expression
type LinearExpression []Term

// String helper for LinearExpression
func (l LinearExpression) String() string {
	res := ""
	for _, t := range l {
		res += t.String()
		res += "+ "
	}
	res = res[:len(res)-2]
	return res
}

// R1C used to compute the wires (wo pointers)
type R1C struct {
	L      LinearExpression
	R      LinearExpression
	O      LinearExpression
	Solver frontend.SolvingMethod
}

// String helper for a Rank1 Constraint
func (r R1C) String() string {
	res := "(" + r.L.String() + ")*(" + r.R.String() + ")=" + r.O.String()
	return res
}

// compute left, right, o part of a r1cs constraint
// this function is called when all the wires have been computed
// it instantiates the l, r o part of a R1C
func (r1c *R1C) instantiate(r1cs *R1CS, wireValues []fr.Element) (a, b, c fr.Element) {

	var tmp fr.Element

	for _, t := range r1c.L {
		debug.Assert(len(wireValues) > int(t.ID), "trying to access out of bound wire in wiretracker")
		tmp.Mul(&t.Coeff, &wireValues[t.ID])
		a.Add(&a, &tmp)
	}

	for _, t := range r1c.R {
		debug.Assert(len(wireValues) > int(t.ID), "trying to access out of bound wire in wiretracker")
		tmp.Mul(&t.Coeff, &wireValues[t.ID])
		b.Add(&b, &tmp)
	}

	for _, t := range r1c.O {
		debug.Assert(len(wireValues) > int(t.ID), "trying to access out of bound wire in wiretracker")
		tmp.Mul(&t.Coeff, &wireValues[t.ID])
		c.Add(&c, &tmp)
	}

	return
}

// solveR1c computes a wire by solving a r1cs
// the function searches for the unset wire (either the unset wire is
// alone, or it can be computed without ambiguity using the other computed wires
// , eg when doing a binary decomposition: either way the missing wire can
// be computed without ambiguity because the r1cs is correctly ordered)
func (r1c *R1C) solveR1c(wireInstantiated []bool, wireValues []fr.Element) {

	switch r1c.Solver {

	// in this case we solve a R1C by isolating the uncomputed wire
	case frontend.SingleOutput:

		// the index of the non zero entry shows if L, R or O has an uninstantiated wire
		// the content is the ID of the wire non instantiated
		location := [3]int64{-1, -1, -1}

		var tmp, a, b, c, backupCoeff fr.Element

		for _, t := range r1c.L {
			if wireInstantiated[t.ID] {
				tmp.Mul(&t.Coeff, &wireValues[t.ID])
				a.Add(&a, &tmp)
			} else {
				backupCoeff.Set(&t.Coeff)
				location[0] = t.ID
			}
		}

		for _, t := range r1c.R {
			if wireInstantiated[t.ID] {
				tmp.Mul(&t.Coeff, &wireValues[t.ID])
				b.Add(&b, &tmp)
			} else {
				backupCoeff.Set(&t.Coeff)
				location[1] = t.ID
			}
		}

		for _, t := range r1c.O {
			if wireInstantiated[t.ID] {
				tmp.Mul(&t.Coeff, &wireValues[t.ID])
				c.Add(&c, &tmp)
			} else {
				backupCoeff.Set(&t.Coeff)
				location[2] = t.ID
			}
		}

		var zero fr.Element

		if location[0] != -1 {
			id := location[0]
			if b.Equal(&zero) {
				wireValues[id].SetZero()
			} else {
				wireValues[id].Div(&c, &b).
					Sub(&wireValues[id], &a).
					Mul(&wireValues[id], &backupCoeff)
			}
			wireInstantiated[id] = true
		} else if location[1] != -1 {
			id := location[1]
			if a.Equal(&zero) {
				wireValues[id].SetZero()
			} else {
				wireValues[id].Div(&c, &a).
					Sub(&wireValues[id], &b).
					Mul(&wireValues[id], &backupCoeff)
			}
			wireInstantiated[id] = true
		} else if location[2] != -1 {
			id := location[2]
			wireValues[id].Mul(&a, &b).
				Sub(&wireValues[id], &c).
				Mul(&wireValues[id], &backupCoeff)
			wireInstantiated[id] = true
		}

	// in the case the R1C is solved by directly computing the binary decomposition
	// of the variable
	case frontend.BinaryDec:

		// the binary decomposition must be called on the non Mont form of the number
		n := wireValues[r1c.O[0].ID].ToRegular()
		nbBits := len(r1c.L)

		// binary decomposition of n
		var i, j int
		for i*64 < nbBits {
			j = 0
			for j < 64 && i*64+j < len(r1c.L) {
				ithbit := (n[i] >> uint(j)) & 1
				if !wireInstantiated[r1c.L[i*64+j].ID] {
					wireValues[r1c.L[i*64+j].ID].SetUint64(ithbit)
					wireInstantiated[r1c.L[i*64+j].ID] = true
				}
				j++
			}
			i++
		}
	default:
		panic("unimplemented solving method")
	}
}
